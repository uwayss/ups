import { program } from "commander";
import { promises as fs } from "fs";
import os from "os";
import path from "path";
import process from "process";
import ignore from "ignore";
import { baseConfig } from "../config/dumpConfig.js";

async function loadUserConfig(projectRoot) {
  const configPath = path.join(projectRoot, "ups.config.json");
  try {
    const rawConfig = await fs.readFile(configPath, "utf-8");
    return JSON.parse(rawConfig);
  } catch (err) {
    if (err.code === "ENOENT") {
      return {}; // No config file is not an error
    }
    console.warn(
      `‚ö†Ô∏è Warning: Could not load or parse ups.config.json: ${err.message}`
    );
    return {};
  }
}

async function generateFileDump(
  projectRoot,
  outputFile,
  targetFolder,
  userConfig
) {
  const dumpConfig = userConfig.dump || {};
  const excludeDirs = new Set([
    ...baseConfig.excludeDirs,
    ...(dumpConfig.excludeDirs || []),
  ]);
  const excludeFiles = new Set([
    ...baseConfig.excludeFiles,
    ...(dumpConfig.excludeFiles || []),
  ]);
  const excludeExtensions = new Set([
    ...baseConfig.excludeExtensions,
    ...(dumpConfig.excludeExtensions || []),
  ]);
  const ignoreMarker = dumpConfig.ignoreMarker || "ups-ignore-rest";

  let outputContent = `// AUTOGENERATED CODEBASE DUMP\n`;
  outputContent += `// Project Root: ${projectRoot}\n`;
  outputContent += `// Date: ${new Date().toISOString()}\n`;
  outputContent += `// Target Folder: ${
    targetFolder || "All (respecting exclusions)"
  }\n\n`;

  async function walk(currentDir, processingRoot, parentIg) {
    let ig = parentIg;
    const gitignorePath = path.join(currentDir, ".gitignore");
    try {
      const gitignoreContent = await fs.readFile(gitignorePath, "utf-8");
      ig = parentIg.add(gitignoreContent);
    } catch (err) {
      if (err.code !== "ENOENT") {
        console.warn(
          `‚ö†Ô∏è Warning: Could not read .gitignore in ${currentDir}: ${err.message}`
        );
      }
    }

    let entries;
    try {
      entries = await fs.readdir(currentDir, { withFileTypes: true });
    } catch (err) {
      if (err.code === "ENOENT" || err.code === "EACCES") {
        console.warn(`Warning: Cannot read directory, skipping: ${currentDir}`);
        return;
      }
      throw err;
    }

    for (const entry of entries) {
      const entryPath = path.join(currentDir, entry.name);
      const relativePath = path
        .relative(processingRoot, entryPath)
        .replace(/\\/g, "/");

      if (ig.ignores(relativePath)) {
        continue;
      }

      if (entry.isDirectory()) {
        if (
          !excludeDirs.has(entry.name) &&
          entry.name !== path.basename(outputFile)
        ) {
          await walk(entryPath, processingRoot, ig);
        }
      } else if (entry.isFile()) {
        const fileExtension = path.extname(entry.name).toLowerCase();
        if (
          !excludeDirs.has(path.dirname(relativePath)) &&
          !excludeFiles.has(entry.name) &&
          !excludeExtensions.has(fileExtension) &&
          entryPath !== path.resolve(outputFile)
        ) {
          try {
            let content = await fs.readFile(entryPath, "utf-8");

            if (ignoreMarker) {
              const lines = content.split("\n");
              let stopIndex = -1;

              for (let i = 0; i < lines.length; i++) {
                if (lines[i].includes(ignoreMarker)) {
                  stopIndex = i;
                  break;
                }
              }

              if (stopIndex !== -1) {
                const slicedLines = lines.slice(0, stopIndex + 1);
                content = slicedLines.join("\n");
              }
            }

            outputContent += `\n// FILE: ${relativePath}\n`;
            if (content.endsWith("\n")) {
              outputContent += content;
            } else {
              outputContent += content + "\n";
            }
          } catch (error) {
            outputContent += `\n// FILE: ${relativePath} (Skipped: ${
              error.code || "Unreadable"
            })\n`;
          }
        }
      }
    }
  }

  const resolvedProjectRoot = path.resolve(projectRoot);
  let actualRootToWalk = resolvedProjectRoot;

  if (targetFolder) {
    actualRootToWalk = path.join(resolvedProjectRoot, targetFolder);
    const stats = await fs.stat(actualRootToWalk).catch(() => null);
    if (!stats) {
      console.error(
        `Error: Target '${targetFolder}' not found or inaccessible.`
      );
      process.exit(1);
    }
    if (stats.isFile()) {
      const relativePath = path
        .relative(resolvedProjectRoot, actualRootToWalk)
        .replace(/\\/g, "/");
      try {
        const content = await fs.readFile(actualRootToWalk, "utf-8");
        outputContent += `\n// FILE: ${relativePath}\n`;
        outputContent += content + "\n";
      } catch (error) {
        outputContent += `\n// FILE: ${relativePath} (Skipped: Error reading file ${error.message})\n`;
      }
    } else {
      await walk(actualRootToWalk, actualRootToWalk, ignore());
    }
  } else {
    await walk(resolvedProjectRoot, resolvedProjectRoot, ignore());
  }

  try {
    await fs.mkdir(path.dirname(outputFile), { recursive: true });
    await fs.writeFile(outputFile, outputContent, "utf-8");
    console.log(`‚úÖ File dump created: ${path.resolve(outputFile)}`);
  } catch (error) {
    console.error(
      `‚ùå Error writing to output file '${outputFile}': ${error.message}`
    );
    process.exit(1);
  }
}

async function main() {
  console.log("üöÄ Starting dump.js script...");
  program
    .argument("[targetPath]", "Optional target file or folder to dump.")
    .option("-o, --output <filename>", "Specify the output filename.")
    .parse(process.argv);

  const projectRoot = process.cwd();
  const options = program.opts();
  const targetPathArg = program.args[0];

  const userConfig = await loadUserConfig(projectRoot);

  await generateFileDump(
    projectRoot,
    determineOutputFile(options, userConfig, projectRoot, targetPathArg),
    targetPathArg,
    userConfig
  );
  console.log("‚ú® Script completed successfully");
}

function determineOutputFile(options, userConfig, projectRoot, targetPathArg) {
  const dumpConfig = userConfig.dump || {};
  if (options.output) {
    return path.isAbsolute(options.output)
      ? options.output
      : path.join(process.cwd(), options.output);
  }

  const customDumpPath = dumpConfig.dumpPath;
  const baseDumpDir = customDumpPath
    ? customDumpPath.replace("~", os.homedir())
    : path.join(os.homedir(), "Desktop");

  const parentFolderName = path.basename(projectRoot);
  const timestamp = new Date().toISOString().slice(11, 19).replace(/:/g, "");
  const targetBasename = targetPathArg
    ? `_${path.basename(targetPathArg).replace(/\./g, "_")}`
    : "";
  const outputFilename = `${parentFolderName}_codebase${targetBasename}_${timestamp}.txt`;

  return path.join(baseDumpDir, outputFilename);
}

main().catch((err) => {
  console.error("‚ùå Script failed:", err.message);
  process.exit(1);
});
