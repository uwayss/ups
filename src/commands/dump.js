import { program } from "commander";
import { promises as fs } from "fs";
import os from "os";
import path from "path";
import process from "process";
import ignore from "ignore";

async function loadUserConfig(projectRoot) {
  const configPath = path.join(projectRoot, "ups.config.json");
  try {
    const rawConfig = await fs.readFile(configPath, "utf-8");
    return JSON.parse(rawConfig);
  } catch (err) {
    if (err.code === "ENOENT") {
      return {}; // No config file is not an error
    }
    console.warn(
      `‚ö†Ô∏è Warning: Could not load or parse ups.config.json: ${err.message}`
    );
    return {};
  }
}

async function generateFileDump(
  projectRoot,
  outputFile,
  targetFolder,
  userConfig
) {
  const baseConfig = {
    excludeDirs: [
      ".git",
      "__pycache__",
      "node_modules",
      ".expo",
      ".yarn",
      "coverage",
      "build",
      ".gradle",
      ".idea",
      ".cxx",
      "xcuserdata",
      "DerivedData",
      "Pods",
      "fastlane",
      "bundle",

      "codebase",
      "assets",
      ".github",
      "dist",
      "bin",
      "updates",
    ],
    excludeFiles: [
      "package-lock.json",
      "pnpm-lock.yaml",
      "bun.lockb",
      ".DS_Store",
      "local.properties",
      ".xcode.env.local",
      "npm-debug.log",
      "yarn-error.log",
      ".metro-health-check",
      "ups.config.json",
    ],
    excludeExtensions: [
      ".apk",
      ".aar",
      ".jar",
      ".keystore",
      ".jks",
      ".hprof",
      ".iml",
      ".pbxuser",
      ".mode1v3",
      ".mode2v3",
      ".perspectivev3",
      ".xccheckout",
      ".moved-aside",
      ".hmap",
      ".ipa",
      ".xcuserstate",
      ".jsbundle",
      ".wasm",
      ".dat",
      ".bin",
      ".db",
      ".sqlite",
      ".obj",
      ".pdb",
      ".tlog",
      ".lib",
      ".exp",
      ".dll",
      ".so",
      ".dylib",
      ".class",
      ".dex",
      ".gradle-build",
      ".log",
      ".lock",
      ".png",
      ".jpg",
      ".jpeg",
      ".gif",
      ".bmp",
      ".tiff",
      ".ico",
      ".webp",
      ".heic",
      ".mp3",
      ".wav",
      ".ogg",
      ".flac",
      ".aac",
      ".mp4",
      ".mov",
      ".avi",
      ".wmv",
      ".mkv",
      ".webm",
      ".ttf",
      ".otf",
      ".woff",
      ".woff2",
      ".zip",
      ".tar",
      ".gz",
      ".rar",
      ".7z",
      ".bz2",
      ".xz",
      ".pdf",
      ".doc",
      ".docx",
      ".xls",
      ".xlsx",
      ".ppt",
      ".pptx",
      ".psd",
      ".ai",
      ".indd",
      ".exe",
      ".dmg",
      ".app",
      ".tsbuildinfo",
    ],
  };

  const dumpConfig = userConfig.dump || {};
  const excludeDirs = new Set([
    ...baseConfig.excludeDirs,
    ...(dumpConfig.excludeDirs || []),
  ]);
  const excludeFiles = new Set([
    ...baseConfig.excludeFiles,
    ...(dumpConfig.excludeFiles || []),
  ]);
  const excludeExtensions = new Set([
    ...baseConfig.excludeExtensions,
    ...(dumpConfig.excludeExtensions || []),
  ]);

  let outputContent = `// AUTOGENERATED CODEBASE DUMP\n`;
  outputContent += `// Project Root: ${projectRoot}\n`;
  outputContent += `// Date: ${new Date().toISOString()}\n`;
  outputContent += `// Target Folder: ${targetFolder || "All (respecting exclusions)"}\n\n`;

  async function walk(currentDir, processingRoot, parentIg) {
    let ig = parentIg;
    const gitignorePath = path.join(currentDir, ".gitignore");
    try {
      const gitignoreContent = await fs.readFile(gitignorePath, "utf-8");
      ig = parentIg.add(gitignoreContent);
    } catch (err) {
      if (err.code !== "ENOENT") {
        console.warn(
          `‚ö†Ô∏è Warning: Could not read .gitignore in ${currentDir}: ${err.message}`
        );
      }
    }

    let entries;
    try {
      entries = await fs.readdir(currentDir, { withFileTypes: true });
    } catch (err) {
      if (err.code === "ENOENT" || err.code === "EACCES") {
        console.warn(`Warning: Cannot read directory, skipping: ${currentDir}`);
        return;
      }
      throw err;
    }

    for (const entry of entries) {
      const entryPath = path.join(currentDir, entry.name);
      const relativePath = path
        .relative(processingRoot, entryPath)
        .replace(/\\/g, "/");

      if (ig.ignores(relativePath)) {
        continue;
      }

      if (entry.isDirectory()) {
        if (
          !excludeDirs.has(entry.name) &&
          entry.name !== path.basename(outputFile)
        ) {
          await walk(entryPath, processingRoot, ig);
        }
      } else if (entry.isFile()) {
        const fileExtension = path.extname(entry.name).toLowerCase();
        if (
          !excludeDirs.has(path.dirname(relativePath)) &&
          !excludeFiles.has(entry.name) &&
          !excludeExtensions.has(fileExtension) &&
          entryPath !== path.resolve(outputFile)
        ) {
          try {
            const content = await fs.readFile(entryPath, "utf-8");
            outputContent += `\n// FILE: ${relativePath}\n`;
            outputContent += content + "\n";
          } catch (error) {
            outputContent += `\n// FILE: ${relativePath} (Skipped: ${error.code || "Unreadable"})\n`;
          }
        }
      }
    }
  }

  const resolvedProjectRoot = path.resolve(projectRoot);
  let actualRootToWalk = resolvedProjectRoot;

  if (targetFolder) {
    actualRootToWalk = path.join(resolvedProjectRoot, targetFolder);
    const stats = await fs.stat(actualRootToWalk).catch(() => null);
    if (!stats) {
      console.error(
        `Error: Target '${targetFolder}' not found or inaccessible.`
      );
      process.exit(1);
    }
    if (stats.isFile()) {
      const relativePath = path
        .relative(resolvedProjectRoot, actualRootToWalk)
        .replace(/\\/g, "/");
      try {
        const content = await fs.readFile(actualRootToWalk, "utf-8");
        outputContent += `\n// FILE: ${relativePath}\n`;
        outputContent += content + "\n";
      } catch (error) {
        outputContent += `\n// FILE: ${relativePath} (Skipped: Error reading file ${error.message})\n`;
      }
    } else {
      await walk(actualRootToWalk, actualRootToWalk, ignore());
    }
  } else {
    await walk(resolvedProjectRoot, resolvedProjectRoot, ignore());
  }

  try {
    await fs.mkdir(path.dirname(outputFile), { recursive: true });
    await fs.writeFile(outputFile, outputContent, "utf-8");
    console.log(`‚úÖ File dump created: ${path.resolve(outputFile)}`);
  } catch (error) {
    console.error(
      `‚ùå Error writing to output file '${outputFile}': ${error.message}`
    );
    process.exit(1);
  }
}

async function main() {
  console.log("üöÄ Starting dump.js script...");
  program
    .argument("[targetPath]", "Optional target file or folder to dump.")
    .option("-o, --output <filename>", "Specify the output filename.")
    .parse(process.argv);

  const projectRoot = process.cwd();
  const options = program.opts();
  const targetPathArg = program.args[0];

  const userConfig = await loadUserConfig(projectRoot);

  const dumpConfig = userConfig.dump || {};
  const customDumpPath = dumpConfig.dumpPath;
  const baseDumpDir = customDumpPath
    ? customDumpPath.replace("~", os.homedir())
    : path.join(os.homedir(), "Desktop");

  let outputFilename;
  if (options.output) {
    outputFilename = options.output;
  } else {
    const parentFolderName = path.basename(projectRoot);
    const timestamp = new Date().toISOString().slice(11, 19).replace(/:/g, "");
    const targetBasename = targetPathArg
      ? `_${path.basename(targetPathArg).replace(/\./g, "_")}`
      : "";
    outputFilename = `${parentFolderName}_codebase${targetBasename}_${timestamp}.txt`;
  }

  const outputFile = path.isAbsolute(outputFilename)
    ? outputFilename
    : path.join(baseDumpDir, outputFilename);

  await generateFileDump(
    projectRoot,
    outputFile,
    targetPathArg,
    userConfig
  );
  console.log("‚ú® Script completed successfully");
}

main().catch((err) => {
  console.error("‚ùå Script failed:", err.message);
  process.exit(1);
});